/*

Package controllers is autogenerated
and containing scaffold outputs
as well as manually created sub-packages
and files.

*/
package controllers

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"github.com/fabric8-services/build-tool-detector/app"
	"github.com/fabric8-services/build-tool-detector/auth/client"
	"github.com/fabric8-services/build-tool-detector/config"
	errs "github.com/fabric8-services/build-tool-detector/controllers/error"
	"github.com/fabric8-services/build-tool-detector/domain/repository"
	"github.com/fabric8-services/build-tool-detector/domain/repository/github"
	"github.com/fabric8-services/build-tool-detector/domain/types"
	"github.com/fabric8-services/build-tool-detector/log"
	"github.com/fabric8-services/fabric8-common/goasupport"
	"github.com/goadesign/goa"
	goaclient "github.com/goadesign/goa/client"
	goajwt "github.com/goadesign/goa/middleware/security/jwt"
	"io/ioutil"
	"net/http"
	"net/url"
)

var (
	// ErrFailedJSONMarshal unable to marshal json.
	ErrFailedJSONMarshal = errors.New("unable to marshal json")

	// ErrFailedPropagate unable to propagate error.
	ErrFailedPropagate = errors.New("unable to propagate error")
)

const (
	errorz                      = "error"
	contentType                 = "Content-Type"
	applicationJSON             = "application/json"
	buildToolDetectorController = "BuildToolDetectorController"
)

// BuildToolDetectorController implements the build-tool-detector resource.
type BuildToolDetectorController struct {
	*goa.Controller
	config.Configuration
	httpClient *http.Client
}

// NewBuildToolDetectorController creates a build-tool-detector controller.
func NewBuildToolDetectorController(service *goa.Service, configuration config.Configuration) *BuildToolDetectorController {
	return &BuildToolDetectorController{
		Controller: service.NewController(buildToolDetectorController),
		Configuration: configuration,
		httpClient:  http.DefaultClient,
	}
}

// Show runs the show action.
func (c *BuildToolDetectorController) Show(ctx *app.ShowBuildToolDetectorContext) error {
	rawURL := ctx.URL
	ctx.ResponseWriter.Header().Set(contentType, applicationJSON)

	// Get auth service to retrieve GH's user token
	u, err := url.Parse(c.Configuration.GetAuthServiceURL())
	if err != nil {
		return handleError(ctx, err)
	}
	authClient := client.New(goaclient.HTTPClientDoer(c.httpClient))
	authClient.Host = u.Host
	authClient.Scheme = u.Scheme
	if goajwt.ContextJWT(ctx) != nil {
		authClient.SetJWTSigner(goasupport.NewForwardSigner(ctx))
	} else {
		log.Logger().Info(ctx, nil, "no token in context")
	}
	tr := tokenRetriever{authClient: authClient, context: ctx}
	scm, err := c.getScm(ctx)
	if err != nil {
		return handleError(ctx, err)
	}
	token, err := tr.tokenForService(*scm)
	if err != nil {
		return handleError(ctx, err)
	}
	repositoryService, err := repository.CreateService(rawURL, ctx.Branch, c.Configuration, *token)
	if err != nil {
		return handleError(ctx, err)
	}
	buildToolType, err := repositoryService.DetectBuildTool(ctx.Context)
	if err != nil {
		return handleError(ctx, err)
	}

	buildTool := handleSuccess(*buildToolType)
	return ctx.OK(buildTool)
}

// handleSuccess handles returning
// the correct json for 200 OK responses.
func handleSuccess(buildToolType string) *app.GoaBuildToolDetector {
	switch buildToolType {
	case types.Maven:
		return types.NewMaven()
	case types.NodeJS:
		return types.NewNodeJS()
	case types.Unknown:
		return types.NewUnknown()
	default:
		return types.NewUnknown()
	}
}

// handleError handles returning
// the correct http responses upon error.
func handleError(ctx *app.ShowBuildToolDetectorContext, err error) error {
	switch err.Error() {
	case github.ErrInvalidPath.Error():
		httpError := errs.ErrBadRequest(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.BadRequest()
	case github.ErrResourceNotFound.Error():
		httpError := errs.ErrNotFoundError(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.NotFound()
	case repository.ErrUnsupportedService.Error(),
		github.ErrUnsupportedGithubURL.Error():
		httpError := errs.ErrInternalServerError(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.InternalServerError()
	case github.ErrFailedContentRetrieval.Error():
		buildTool := types.NewUnknown()
		return ctx.OK(buildTool)
	default:
		return ctx.InternalServerError()
	}
}

// getScm get the source control management system used from configuration.
func (c *BuildToolDetectorController) getScm(ctx *app.ShowBuildToolDetectorContext) (*string, error) {
	value := c.Configuration.GetScm()
	if strings.ToLower(value) != "github" {
		err := errors.New("only GitHub scm supported")
		log.Logger().WithError(err)
		return nil, err
	}
	scm := fmt.Sprintf("http://%s.com", c.Configuration.GetScm())
	return &scm, nil
}

// formatResponse writes the header
// and formats the response.
func formatResponse(ctx *app.ShowBuildToolDetectorContext, httpTypeError *errs.HTTPTypeError) error {
	ctx.WriteHeader(httpTypeError.StatusCode)
	jsonHTTPTypeError, err := json.Marshal(httpTypeError)
	if err != nil {
		log.Logger().WithError(err).WithField(errorz, httpTypeError).Errorf(ErrFailedJSONMarshal.Error())
		return ctx.InternalServerError()
	}

	if _, err := fmt.Fprint(ctx.ResponseWriter, string(jsonHTTPTypeError)); err != nil {
		log.Logger().WithError(err).WithField(errorz, jsonHTTPTypeError).Errorf(ErrFailedPropagate.Error())
		return ctx.InternalServerError()
	}
	return nil
}

type tokenRetriever struct {
	authClient *client.Client
	context    *app.ShowBuildToolDetectorContext
}

// tokenForService calls auth service to retrieve a token for an external service (ie: GitHub).
func (tr *tokenRetriever) tokenForService(forService string) (*string, error) {

	resp, err := tr.authClient.RetrieveToken(goasupport.ForwardContextRequestID(tr.context), client.RetrieveTokenPath(), forService, nil)
	if err != nil {
		return nil, handleError(tr.context , err)
	}

	defer resp.Body.Close()

	respBody, err := ioutil.ReadAll(resp.Body)

	status := resp.StatusCode
	if status != http.StatusOK {
		log.Logger().Error(nil, map[string]interface{}{
			"err":          err,
			"request_path": client.ShowUserPath(),
			"for_service":  forService,
			"http_status":  status,
		}, "failed to GET token from auth service due to HTTP error %s", status)
		return nil, handleError(tr.context , err)
	}

	var respType client.TokenData
	err = json.Unmarshal(respBody, &respType)
	if err != nil {
		log.Logger().Error(nil, map[string]interface{}{
			"err":           err,
			"request_path":  client.ShowUserPath(),
			"for_service":   forService,
			"http_status":   status,
			"response_body": respBody,
		}, "unable to unmarshal Auth token")
		return nil, handleError(tr.context , err)
	}

	return respType.AccessToken, nil
}
